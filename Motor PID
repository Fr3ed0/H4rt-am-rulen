#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include <math.h>
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
Adafruit_DCMotor *leftMotor = AFMS.getMotor(1);
Adafruit_DCMotor *rightMotor = AFMS.getMotor(2);

volatile  uint8_t lastB = 0;   
volatile  uint16_t counterA;
volatile  uint16_t counterB;
volatile int8_t altAB = 0;
volatile long encoderWert = 0;
 
#define LINKERMOTORPIN 2
#define RECHTERMOTORPIN 3

#define GREIFARMPINA 4
#define GREIFARMPINB 5

//tacho stuff
long jetzt;
long altZeit, altZeitb;
int prevA;
int newA;

const byte deltaT = 15;
const byte deltaTacho=100; // chose your value according to your prefered max range 

//motorPID
int actualSpeedA; //our tacho
int wantedSpeedA; //the value set by our pid sensor cycle
int errorSpeedA; //the value used to adjust motor power

//greifarm stuff
int8_t schrittTab[16] = {0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0}; 

void setup() {
  PCICR |= (1 << PCIE2);
  PCMSK2 |= (1 << LINKERMOTORPIN);
  PCMSK2 |= (1 << RECHTERMOTORPIN);
  PCMSK2 |= (1 << GREIFARMPINA);
  PCMSK2 |= (1 << GREIFARMPINB);
  DDRD&=~PCMSK2;
      Serial.begin(9600);
      AFMS.begin();
    leftMotor->run(FORWARD);
    leftMotor->run(RELEASE);
    leftMotor->run(BACKWARD);
    interrupts();
}

void loop() {
  
  jetzt = millis();
  if((jetzt - altZeitb) > deltaTacho){
    altZeitb = jetzt;    
    actualSpeedA=counterA-prevA;
    newA=counterA;
    }
    
   if((jetzt - altZeit) > deltaT){
      altZeit = jetzt;
//////////////////////////////////////////////////////////         
         errorSpeedA = wantedSpeedA - actualSpeedA;
     }
        leftSpeed= errorSpeedA * kM 
        
    if (leftSpeed >= 255){
    leftSpeed = 255;
    }
    if (rightSpeed >= 255){
      rightSpeed = 255;
    }
    if (leftSpeed <= 0) {
      leftSpeed = 0;
    }
    if (rightSpeed <= 0){
      rightSpeed = 0;
    }
        
        leftMotor->setSpeed();
          
  #ifdef MOTOR
  Serial.println(SpeedA);
  #endif
  
}

ISR(PCINT2_vect){ //speciifc routine

  uint8_t newB = PIND;                  // aktuellen Port speichern
  uint8_t chgB = newB ^ lastB;          // ge채nderte Bits zum letzten Port
  lastB = newB;                         // neuer Port wird zum alten f체r die n채chste Runde

  if (chgB) {                             // wenn mindestens 1 Bit ge채ndert   
    
    if (chgB & (1 << LINKERMOTORPIN)) {
     counterA++;
    }
     if (chgB & (1 << RECHTERMOTORPIN)) {
     counterB++;
    }
    if (chgB & ((1 <<GREIFARMPINA) | (1 << GREIFARMPINB)) ){
        altAB <<= 2; 
        altAB &= B00001100;
   //   altAB |= ((0b00000100 & newB) << 1) | (0b00001000 & newB); 
   //   altAB |= (((1 << GREIFARMPINA) & newB) << 1) | ((1 << GREIFARMPINB) & newB);
        altAB |= (digitalRead(GREIFARMPINA) << 1) | digitalRead(GREIFARMPINB); 
        encoderWert += schrittTab[altAB];
    }

  }
}
